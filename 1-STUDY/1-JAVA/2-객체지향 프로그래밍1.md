# 객체지향언어
## 1. 객체지향언어의 역사
- 초기에는 탑 다운 방식의 순차적 프로그래밍 방식을 사용 -> 코드가 길어질수록 코드 중복 발생, 유지보수가 어려워짐
- GOTO문의 문제를 해결하기 위해 구조적 프로그래밍 방식 채택 -> 데이터 처리 방식(프로시저 실행)만 구조화, 데이터는 구조화 하지 못함
- 대안으로 객체 지향 프로그래밍 등장 -> 객체를 만들고 독립성을 높게 만들면 객체 수정없이 재사용하기 때문에 유지보수가 쉬워짐

## 2. 객체지향언어
- 객체를 만들고 서로 상호작용하도록 프로그래밍하는 언어
- 잘 알려진 특징으로 캡슐화, 상속, 다형성, 추상화가 있음
	- 제어자(public, private 등)와 메서드로 코드 보호 <- 캡슐화
	- 기존 코드를 참고하고 새로운 것 만 추가 <- 상속, 다형성
	- 클래스를 만드는 과정 <- 추상화
- 시뮬라67, 스몰토크, C++, 자바 등 객체지향언어 존재

## 3. 객체지향프로그래밍개발 단계
1. 클래스 설계
2. 클래스로 객체를 생성
3. 생성된 객체를 이용

## 4. 잘못된 오해
- 흔히 객체지향과 절차적을 반대의 개념으로 알고 있는데 영어 번역의 오류임
- Procedural Programming, Procedural를 '절차'로 번역하는데, 프로시저(함수)를 뜻함
- 둘다 명령형 프로그래밍의 일종
- '절차지향'이라는 단어는 존재하지 않으므로 잘못된 표현
- 절차적 프로그래밍은 함수 호출을 통해 추상화와 재사용성에 본질을 둠

****
# 클래스와 객체
## 1. 클래스와 객체의 정의와 용도
1. 객체
	- 정의 : 물리적(눈에 보이거나), 추상적(눈에 안보이거나)인 것 중에서 자신의 속성을 가지고 있으며 식별 가능한 것
	- 용도 : 클래스로 객체를 생성하여 사용
2. 클래스
	- 정의 : 객체의 속성과 기능을 코드로 구현한 것, '클래스를 정의한다' - 객체를 클래스로 구현하는 것, 객체를 만들기 위한 설계도
	- 용도 : 객체를 생성하기 위한 필드와 메서드가 정의되어 있으며 객체를 생성할 때 사용

## 2. 객체와  인스턴스
1. 객체 : 클래스의 인스턴스
2. 인스턴스
	- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함, 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음
	- 인스턴스화 : 클래스로부터 객체를 만드는 과정 ( ClassName var = new ClassName(); < 인스턴스화, 메모리에 객체를 저장)
2. 정리
	- 객체는 구현할 모든 것  
	- 클래스는 객체를 구현하기 위한 설계도
	- 객체는 클래스의 인스턴스
	- 클래스로 객체를 만드는 과정 '인스턴스화'

## 3. 객체의 구성요소 - 속성과 기능
1. 속성과 기능(멤버)
	- 객체에는 속성과 기능이 존재
	- 사람이라는 객체를 속성(나이, 이름, 성별), 기능(뛰다, 말하다. 앉다)으로 구성
	- 이런 구성요소를 통틀어서 멤버라고 함
2. 속성(필드, 변수)
	```java
	public class Person {  
		String name; // 변수  
	}
	```
3. 기능(메서드, 함수)
	```java
	public class Person {  
		String name; // 변수  
		public void sayMyName() { // 메서드  
			System.out.println(name);
		}  
	} 
	```

## 4. 인스턴스의 생성과 사용
```java
// 1. 클래스 선언
public class Person {  
	String name; <- 변수  
	public void sayMyName() { // 메서드  
		System.out.println(name);
	}  
}

// 2. 인스턴스 생성
//// 클래스명 참조변수명 = new 클래스명();  
Person p1 = new Person(); // 인스턴스 생성(객체를 메모리에 할당)
//// new 사용하여 객체를 생성하면 힙 영역에 저장
//// 참조변수명 p1은 힙에 저장된 객체의 주소를 가지고 있음. 스택 영역에 저장되어있음

// 3. 인스턴스 사용
p1.name = '준승'; // p1이 참조하고 있는 인스턴스의 변수 name에 '준승'이라는 값 할당  
p1.sayMyName(); // p1이 참조하고 있는 인스턴스의 메서드를 호출  
//// 결과값으로 콘솔에 준승이 나옴
```

## 5. 객체 배열
- 객체를 참조하는 배열로 기본타입(byte, int 등) 배열은 각 항목에 직접 값을 가지고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지(주소)를 가지고 있음  

## 6. 클래스의 또 다른 정의
-  사용자 정의 타입
	- 정해져 있는 기본타입(byte, int 등) 외로 사용자가 원하는 타입을 만들어 사용 가능 EX) 영어 월 약자(Jan, Feb 등)만 담는 타입을 만들어서 클래스로 사용

****
# 객체지향 프로그래밍 5가지 설계 원칙(SOLID)
> 로버트 C.마틴이 2000년대 초반 객체 지향 프로그래밍 및 설계의 5가지 기본원칙으로 제시한 것

## 1. **S**RP(Single responsibility principle) : 단일 책임 원칙
- **한 클래스는 하나의 책임만 가져야 함**
	- 하나의 모듈에 여러가지 책임이 있다면 수정해야 하는 이유도 여러개가 될 수도 있음
	- 클래스에 하나의 책임 만 갖고 있다면 해당 클래스만 변경하면 됨
```java
public class UserService { 
	public void addUser(){ // 사용자 추가 기능
		... // 암호화 하는 로직
		... // 사용자 코드 자동 생성 로직
	}
}
/*
암호화 방식 개선, 사용자 코드 자동 생성 규칙 변경이라는 요구사항이 생길 시 하나의 모듈에 수정해야 하는 이유도 여러개가 됨
*/
	
public class UserService { 

	private PasswordEncoder passwordEncoder;
	private UserCodeCreater userCodeCreater;
	
	public void addUser(){ // 사용자 추가 기능
		// 메서드 호출
		passwordEncoder.encode();
		userCodeCreater.createUserCode();
	}
}

public class PasswordEncoder {
	public void encode(){
		... // 암호화 하는 로직
	}
}

public class UserCodeCreater {
	public void createUserCode(){
		... // 사용자 코드 자동 생성 로직
	}
}
/*
각각 책임사항에 대해 요구사항이 생길 시 수정해야될 클래스가 명확해짐	
*/
```

## 2. **O**CP(Open-closed principle) : 개방-폐쇄 원칙
- **소프트웨어 구성요소(클래스, 모듈, 함수 등)는 확장에는 열리고 변경에는 닫힘.**
	- 확장에 열림 : 요구사항이 변경될 때 새로운 동작을 추가하여 기능 확장.
	- 변경에 닫힘 : 기존 코드를 수정하지 않고 동작 추가 변경 가능해야 함.
```java
public class StandardPasswordEncoder {
	public void encode(){
		... // 암호화 하는 로직
	}
}

public class UserService { 

	// private PasswordEncoder passwordEncoder; // 기존
	private StandardPasswordEncoder passwordEncoder; // 변경
	...
}
/*
새로운 암호화 정책을 적용하려고 했더니 수정했던 부분과 무관한 UserService 코드를 수정해야하는 상황이 발생함.
-> 변경에 닫히는 원칙에 위반됨
*/

public interface PasswordEncoder{
	void encode();
}

public class StandardPasswordEncoder implements PasswordEncoder {
	@Override
	public void encode(){
		... // 암호화 하는 로직
	}
}

public class UserService { 

	private PasswordEncoder passwordEncoder; // 기존대로 사용
	// private StandardPasswordEncoder passwordEncoder; // 변경안해도 됨
	...
}
/*
StandardPasswordEncoder가 PasswordEncoder를 의존하도록 하여 개방 폐쇄의 원칙에 충족되도록 할 수 있음.
*/
```

## 3. **L**SP(Liskov substitution principle) : 리스코프 치환 원칙
- **서브 타입은 언제나 자신의 기반 타입(Base type)으로 교체할 수 있어야 함.**
	- 상위 타입이 하위 타입으로 변경되어도, 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 함.
	- 상속은 조직도나 계층도가 아닌 분류도가 되어야 함.
	- 리스코프 치환을 지키지 위한 두가지 조건
- 형식적 측면
			- 자식 클래스가 오버라이딩 하는 변수와 메서드는 부모클래스와 형식이 일치해야함
			- 지키지 않으면 에러남
```java
public class Rectangle { 
	private int width; 
	private int height; 
	
	public void setWidth(int width) { 
		this.width = width; 
	} 
	public void setHeight(int height) { 
		this.height = height; 
	} 
	public int getWidth() { 
		return width; 
	} 
	public int getHeight() { 
		return height; 
	} 
}

public class Square extends Rectangle {
	@Override 
	public void setWidth(int width, int height) { // 형식이 맞지 않으면 에러 발생
		...
	}

	...
}
```
- 내용적 측면
	- 자식 클래스가 부모 클래스의 메서드에 담긴 의도, 행동 규약을 위반하지 않아야 함
	- 에러가 안나도 의도하지 않는 결과가 나옴
```java
public class Rectangle { 
	...
	
	public void setWidth(int width) { 
		this.width = width; 
	} 
	public void setHeight(int height) { 
		this.height = height; 
	} 
	
	...
}

public class Square extends Rectangle {
	@Override 
	public void setWidth(int width) { // 의도가 달라지면 다른 결과가 나올 수 있음
		super.setWidth(width); 
		super.setHeight(width);
	}

	@Override 
	public void setHeight(int height) { // 의도가 달라지면 다른 결과가 나올 수 있음
		super.setWidth(height); 
		super.setHeight(height);
	}

	/*
	자식 클래스가 부모 클래스의 메서드에 담긴 의도를 위반 하면 의도하지 않는 결과가 나올 수 있음
	*/
}
```

## 4. **I**SP(Interface segregation principle) : 인터페이스 분리 원칙
- **하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 나음.**
	- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안됨
```java
public interface PasswordEncoder{
	void encode();
}

public class StandardPasswordEncoder implements PasswordEncoder {
	@Override
	public void encode(){
		... // 암호화 하는 로직
	}

	public boolean validate() {
		... // 비밀번호 규칙이 맞는지 체크
	}
}
/*
validate() 메서드를 사용하기 위해서는 구체 클래스인 StandardPasswordEncoder를 주입받아야 하는데 
그러면 불필요한 encode() 메서드까지 접근 가능해지며 인터페이스 분리 원칙을 위배하게 됨
*/

public interface PasswordChecker{
	void validate();
}

public class StandardPasswordEncoder implements PasswordEncoder, PasswordChecker {
	@Override
	public void encode(){
		... // 암호화 하는 로직
	}

	@Override
	public boolean validate() {
		... // 비밀번호 규칙이 맞는지 체크
	}
}
/*
위의 상황을 해결하기 위해서는 비밀번호를 검사하는 별도의 인터페이스를 만들고 인터페이스로 주입받도록 하는 것이 적합
*/
```

## 5. **D**IP(Dependency inversion principle) : 의존관계 역전 원칙
- **구체적인 것이 추상화된 것에 의존해야 함. 자주 변경되는 구체 클래스에 의존하면 안됨, OCP와 유사한 원칙**
	- UserService --의존--> StandardPasswordEncoder
		- StandardPasswordEncoder는 변하기 쉬운 구체 클래스이기 때문에 StandardPasswordEncoder에 의존하는 것은 의존 역전 원칙에 위반됨
	- UserService --의존--> PasswordEncoder <--구현-- StandardPasswordEncoder
		- PasswordEncoder에 의존하므로 비밀번호 암호화 정책이 변경되어도 다른 곳들로 변경이 전파되지 않아 유연한 어플리케이션이 됨.

## 6. 정리
### - SOLID의 핵심은 결국 추상화(모델링)

****
# 변수와 메서드
## 1. 선언위치에 따른 변수의 종류
|변수유형|선언 위치|사용 범위|메모리|생성과 소멸|
|-|-|-|-|-|
|**지역변수(로컬변수)**|함수 내부에 선언|함수 내부에서만 사용|스택|함수 호출 시 생성, 함수 끝나면 소멸|
|**멤버 변수(인스턴스 변수)**|클래스 멤버 변수로 선언|클래스 내부에서 사용 private이 아니면 참조 변수로 다른 클래스에서 사용 가능|힙|인스턴스 생성 시 힙에 생성, 가비지 컬렉터가 메모리 수거할 때 소멸|
|**static 변수(클래스 변수)**|static 예약어를 사용하여 클래스 내부에서 선언|클래스 내부에서 사용하고 private이 아니면 클래스 이름으로 다른 클래스에서 사용 가능|데이터 영역|프로그램 시작 시 데이터 영역에 생성, 프로그램 끝나고 메모리 해제 시 소멸|

## 2. 클래스변수와 인스턴스변수, 지역변수
1. **지역 변수**
	- 함수나 메서드 내부에 선언, 함수 밖에서는 사용할 수 없음
	- 지역 변수가 생성되는 메모리를 스택이라고 함
	- 함수 호출 시 생성, 함수 반환 시 할당된 메모리 공간이 해제되면서 함께 없어짐
2. **멤버 변수**  
	- 인스턴스 변수라고도 함
	- 클래스가 생성될 때 힙 메모리에 생성되는 변수
	- 클래스의 어느 메소드에서나 사용
	- 힙에 생성된 인스턴스가 가비지 컬렉터에 의해 수거되면 메모리에서 사라짐
	- 클래스 내부 여러 메서드에서 사용할 변수는 멤버 변수로 선언하는게 좋음
3. **static 변수**
	- 사용자가 프로그램을 실행하면 메모리에 프로그램이 상주, 프로그램 영역 중 데이터 영역이 존재, 이 영역에 상수, 문자열, static 변수 생성
	- 인스턴스 변수는 객체가 생성되는 new가 되어야 생성, static 변수는 클래스 생성과 상관없이 처음부터 데이터 영역 메모리에 생성
		- 데이터 영역은 상수 영역, static 영역이라고 표현하는 경우 존재
	- private만 아니라면 클래스 외부에서도 객체 생성과 무관하게 사용 가능
	- 프로그램 실행이 끝난 뒤 메모리에서 내려가면 static변수도 소멸
	- 계속 메모리에 상주하므로 크기가 너무 큰 변수는 static으로 선언하지 않는 것이 효율적

## 3. 메서드
- 함수의 한 종류
- 함수란?
	- 하나의 기능을 수행하는 일련의 코드
	- 어떤 기능을 수행하도록 미리 구현해 놓고 필요할 때마다 호출하여 사용
```java
// EX) 더하기 기능을 수행하는 코드를 묶어서 '더하기 함수'로 만들 수 있음
int num1 = 1;
int num2 = 2;
int num1AddNum2 = num1 + num2; // 중복

int grade1 = 90;
int grade2 = 100;
int grade1Addgrade2 = grade1 + grade2; // 중복

// 메서드는 중복된 코드를 제거하기 위해 사용

int num1 = 1;
int num2 = 2;
int num1AddNum2 = add(num1, num2); // 함수 호출

int grade1 = 90;
int grade2 = 100;
int grade1Addgrade2 = add(grade1, grade2); // 함수 호출

int add(int a, int b) { // 함수 선언과 구현
	return a + b;
}
```
- 함수의 장점
	1. 기능을 나누어 코드를 효율적으로 구현(가독성)
	2. 필요할 때마다 함수 호출(재사용, 코드 중복 제거)
	3. 오류 난 기능만 찾아서 수정(유지보수가 쉬워짐)

## 4. 메서드의 선언과 구현
```java
int add(int a, int b) { // 선언
	return a + b; // 구현
}
```
1. 선언
	1. 반환형 int
		- 함수의 결과 값을 반환
		- 반환값이 없는 경우 void로 작성
	2. 함수명 add
		-  함수 기능과 관련 있는 이름으로 선언
		- 소문자로 시작, 동사 사용, 대부분 카멜케이스 명명규칙 따름
	3. 매개변수 int a, int b
		- 메서드의 지역변수
		- 함수 호출 시 자료형에 맞게 함수에 전달, 없는 경우도 존재
2. 구현
	1. 메서드 호출 시 실행시킬 코드 작성
	2. return 예약어로 결과값을 반환
	
## 5. 메서드의 호출
```java
int num1 = 1;
int num2 = 2;
int num1AddNum2 = add(num1, num2); // 함수 호출

// 함수 구현하고 호출하기
int add(int a, int b) { // 함수 선언
	int result = a + b; // 함수 구현
	return result; // 결과값 반환
}
```

## 6. return문
1. return 예약어는 결과값을 반환 한다는 의미, return 값은 반환형에 맞게 작성해야함
2. 반환형이 void인 경우 함수 수행 종료

## 7. JVM의 메모리구조

## 8. 기본형 매개변수와 참조형 매개변수

## 9. 참조형 반환타입

## 10. 재귀호출(recursive call)

## 11. 클래스 메서드(static메서드)와 인스턴스 메서드

## 12. 클래스 멤버와 인스턴스 멤버간의 참조와 호출