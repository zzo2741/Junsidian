# 객체지향언어
## 1. 객체지향언어의 역사
- 초기에는 탑 다운 방식의 순차적 프로그래밍 방식을 사용 -> 코드가 길어질수록 코드 중복 발생, 유지보수가 어려워짐
- GOTO문의 문제를 해결하기 위해 구조적 프로그래밍 방식 채택 -> 데이터 처리 방식(프로시저 실행)만 구조화, 데이터는 구조화 하지 못함
- 대안으로 객체 지향 프로그래밍 등장 -> 객체를 만들고 독립성을 높게 만들면 객체 수정없이 재사용하기 때문에 유지보수가 쉬워짐

## 2. 객체지향언어
- 객체를 만들고 서로 상호작용하도록 프로그래밍하는 언어
- 잘 알려진 특징으로 캡슐화, 상속, 다형성, 추상화가 있음
	- 제어자(public, private 등)와 메소드로 코드 보호 <- 캡슐화
	- 기존 코드를 참고하고 새로운 것 만 추가 <- 상속, 다형성
	- 클래스를 만드는 과정 <- 추상화
- 시뮬라67, 스몰토크, C++, 자바 등 객체지향언어 존재

## 3. 객체지향프로그래밍개발 단계
1. 클래스 설계
2. 클래스로 객체를 생성
3. 생성된 객체를 이용

## 4. 잘못된 오해
- 흔히 객체지향과 절차적을 반대의 개념으로 알고 있는데 영어 번역의 오류임
- Procedural Programming, Procedural를 '절차'로 번역하는데, 프로시저(함수)를 뜻함
- 둘다 명령형 프로그래밍의 일종
- '절차지향'이라는 단어는 존재하지 않으므로 잘못된 표현
- 절차적 프로그래밍은 함수 호출을 통해 추상화와 재사용성에 본질을 둠

****
# 클래스와 객체
## 1. 클래스와 객체의 정의와 용도
1. 객체
	- 정의 : 물리적(눈에 보이거나), 추상적(눈에 안보이거나)인 것 중에서 자신의 속성을 가지고 있으며 식별 가능한 것
	- 용도 : 클래스로 객체를 생성하여 사용
2. 클래스
	- 정의 : 객체의 속성과 기능을 코드로 구현한 것, '클래스를 정의한다' - 객체를 클래스로 구현하는 것, 객체를 만들기 위한 설계도
	- 용도 : 객체를 생성하기 위한 필드와 메소드가 정의되어 있으며 객체를 생성할 때 사용

## 2. 객체와  인스턴스
1. 객체 : 클래스의 인스턴스
2. 인스턴스
	- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함, 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음
	- 인스턴스화 : 클래스로부터 객체를 만드는 과정 ( ClassName var = new ClassName(); < 인스턴스화, 메모리에 객체를 저장)
2. 정리
	- 객체는 구현할 모든 것  
	- 클래스는 객체를 구현하기 위한 설계도
	- 객체는 클래스의 인스턴스
	- 클래스로 객체를 만드는 과정 '인스턴스화'

## 3. 객체의 구성요소 - 속성과 기능
1. 속성과 기능(멤버)
	- 객체에는 속성과 기능이 존재
	- 사람이라는 객체를 속성(나이, 이름, 성별), 기능(뛰다, 말하다. 앉다)으로 구성
	- 이런 구성요소를 통틀어서 멤버라고 함
2. 속성(필드, 변수)
	```java
	public class Person {  
		String name; // 변수  
	}
	```
3. 기능(메소드, 함수)
	```java
	public class Person {  
		String name; // 변수  
		public void sayMyName() { // 메소드  
			System.out.println(name);
		}  
	} 
	```

## 4. 인스턴스의 생성과 사용
```java
// 1. 클래스 선언
public class Person {  
	String name; <- 변수  
	public void sayMyName() { // 메소드  
		System.out.println(name);
	}  
}

// 2. 인스턴스 생성
//// 클래스명 참조변수명 = new 클래스명();  
Person p1 = new Person(); // 인스턴스 생성(객체를 메모리에 할당)
//// new 사용하여 객체를 생성하면 힙 영역에 저장
//// 참조변수명 p1은 힙에 저장된 객체의 주소를 가지고 있음. 스택 영역에 저장되어있음

// 3. 인스턴스 사용
p1.name = '준승'; // p1이 참조하고 있는 인스턴스의 변수 name에 '준승'이라는 값 할당  
p1.sayMyName(); // p1이 참조하고 있는 인스턴스의 메소드를 호출  
//// 결과값으로 콘솔에 준승이 나옴
```

## 5. 객체 배열
- 객체를 참조하는 배열로 기본타입(byte, int 등) 배열은 각 항목에 직접 값을 가지고 있지만, 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지(주소)를 가지고 있음  

## 6. 클래스의 또 다른 정의
-  사용자 정의 타입
	- 정해져 있는 기본타입(byte, int 등) 외로 사용자가 원하는 타입을 만들어 사용 가능 EX) 영어 월 약자(Jan, Feb 등)만 담는 타입을 만들어서 클래스로 사용

****
# 변수와 메서드
## 1. 선언위치에 따른 변수의 종류

## 2. 클래스변수와 인스턴스변수
## 3. 메서드
## 4. 메서드의 선언과 구현
## 5. 메서드의 호출
## 6. return문
## 7. return문
## 8. 기본형 매개변수와 참조형 매개변수
## 9. 참조형 반환타입
## 10. 재귀호출(recursive call)
## 11. 클래스 메서드(static메서드)와 인스턴스 메서드
## 12. 클래스 멤버와 인스턴스 멤버간의 참조와 호출


****
# SOLID(객체지향 프로그래밍 5가지 설계 원칙)
> 로버트 C.마틴이 2000녀대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본원칙으로 제시한 것
## 1. **S**RP(Single responsibility principle) : 단일 책임 원칙
- **한 클래스는 하나의 책임만 가져야 함**
	- 하나의 모듈에 여러가지 책임이 있다면 수정해야 하는 이유도 여러개가 될 수도 있음
	- 클래스에 하나의 책임 만 갖고 있다면 해당 클래스만 변경하면 됨
	```java
	public class UserService { 
		public void addUser(){ // 사용자 추가 기능
			// 암호화 하는 로직
			// 사용자 코드 자동 생성 로직
		}
	}
	/*
	암호화 방식 개선, 사용자 코드 자동 생성 규칙 변경이라는 요구사항이 생길 시 하나의 모듈에 수정해야 하는 이유도 여러개가 됨
	*/

	/****/
	
	public class UserService { 

		private PasswordEncoder passwordEncoder;
		private UserCodeCreater userCodeCreater;
		
		public void addUser(){ // 사용자 추가 기능
			// 메소드 호출
			passwordEncoder.encryptPw();
			userCodeCreater.createUserCode();
		}
	}

	public class PasswordEncoder {
		public void encryptPw(){
			// ... 암호화 하는 로직
		}
	}

	public class UserCodeCreater {
		public void createUserCode(){
			// ... 사용자 코드 자동 생성 로직
		}
	}
	/*
	각각 책임사항에 대해 요구사항이 생길 시 수정해야될 클래스가 명확해짐	
	*/
	```
	
## 2. **O**CP(Open-closed principle) : 개방-폐쇄 원칙
- **소프트웨어 구성요소(클래스, 모듈, 함수 등)는 확장에는 열리고 변경에는 닫힘.**
	- 확장에 열림 : 요구사항이 변경될 때 새로운 동작을 추가하여 기능 확장.
	- 변경에 닫힘 : 기존 코드를 수정하지 않고 동작 추가 변경 가능해야 함.
	```java
	
	```

## 3. **L**SP(Liskov substitution principle) : 리스코프 치환 원칙
- **서브 타입은 언제나 자신의 기반 타입(Base type)으로 교체할 수 있어야 함.**
	- 
## 4. **I**SP(Interface segregation principle) : 인터페이스 분리 원칙
- **하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 나음.**
	- 
## 5. **D**IP(Dependency inversion principle) : 의존관계 역전 원칙
- **구체적인 것이 추상화된 것에 의존해야 함. 자주 변경되는 구체 클래스에 의존하면 안됨.**
	- 